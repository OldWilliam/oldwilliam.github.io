{"meta":{"title":"OldWilliam","subtitle":"Keep Going","description":"积少成多，慢即是快","author":"OldWilliam","url":"www.baidu.com"},"pages":[{"title":"categories","date":"2018-01-01T16:22:16.000Z","updated":"2019-07-03T18:35:39.147Z","comments":true,"path":"categories/index.html","permalink":"www.baidu.com/categories/index.html","excerpt":"","text":""},{"title":"我","date":"2019-07-03T18:37:48.000Z","updated":"2019-07-03T18:40:09.696Z","comments":true,"path":"about/index.html","permalink":"www.baidu.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-01T16:22:05.000Z","updated":"2018-01-01T17:41:00.000Z","comments":true,"path":"tags/index.html","permalink":"www.baidu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ProjectButter","slug":"ProjectButter","date":"2019-07-04T12:27:42.806Z","updated":"2019-07-04T12:34:32.551Z","comments":true,"path":"2019/07/04/ProjectButter/","link":"","permalink":"www.baidu.com/2019/07/04/ProjectButter/","excerpt":"","text":"Vsync和TripleBuffer Vsync本来就存在，是硬件显示设备为了解决画面撕裂Tearing 之前没有在软件层次引入Vysnc，导致屏幕刷新和渲染数据不同步，有以下情况 In Ice Cream Sandwich, processing for the next frame would just kind-of lazily start whenever the system got around to it. 屏幕刷新后，cpu和gpu没有立马去渲染，导致后面开始渲染后剩余时间不多了，渲染不能完成 引入Vsync后 the whole process of making the next frame starts as soon as the last frame is finished In other words, they’re using as much of the 16ms as they can. 但是如果出现GPU、CPU的渲染速度（或者可能是这一帧做的事太多，任务过重Snowballing）赶不上Display的刷新速率的话，会出现卡顿 因为是双缓冲，在第二帧，Display占着A帧，GPU占着B帧，导致第二帧CPU虽然空闲但是没有缓冲了，没法去渲染已经存在的任务，会导致后续又发生卡顿。 另外，只有在Vsync的时候Display和GPU才会交换帧，所以即使上图第一帧的时候，GPU用B Buffer只超出Vsync一点时间，就算他渲染完成，因为不会交换Buffer，所以CPU也拿不到Buffer去渲染 引入三缓冲改善后，CPU可以在第三个Buffer工作，渲染存在的任务，让画面从卡顿恢复。但是再增加缓冲也没用了，因为：1、一共也就三个地方在用Buffer，GPU、CPU、Display，这种利用率最高；2、就三缓冲来说，就已经产生了16ms的延迟。比如说，GPU已经占了两个Vsync周期的情况，那么D Buffer会在32ms后渲染，会对输入行为造成延迟感。 Android is also able to recover from a slowdown more smoothly. Video and Article Google I/O 2012 - For Butter or Worse: Smoothing Out Performance in Android UIs Android Project Butter分析 from 《深入理解Android》作者 Project Butter - How It Works And What It Added","categories":[],"tags":[]},{"title":"Fresco初探","slug":"fresco","date":"2018-03-26T06:44:29.000Z","updated":"2019-07-03T17:29:47.443Z","comments":true,"path":"2018/03/26/fresco/","link":"","permalink":"www.baidu.com/2018/03/26/fresco/","excerpt":"","text":"简介Drawees DraweeView，View层，默认实现类 SimpleDraweeView； DraweeHierarchy，Model层，描述绘制对象数据，持有树状结构的多层Drawable，为了实现UI的可变性，比传统的View嵌套实现更加轻量级，默认实现类GenericDraweeHierarchy； DraweeController，负责处理交互并展现到DrweeView，默认实现类PipelineDraweeController； DraweeControllerBuilder 建造者模式，DraweeController有太多可配置参数； Drawees 负责图片的呈现，它由三个元素组成，有点像MVC模式。Fresco的MVC约束： ImagePipeLine Bitmap处理方式的抽象，各种缓存策略等等。 ImagePipeline就是一个加载图片的组件，如果有可能，甚至可以拿出来让其他图片加载框架用。比如Volley的图片加载组件。 ImagePipeLine工作流程： ImagePipeLine工作流实现： 时序图 使用官方用法 Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;); SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view); draweeView.setImageURI(uri); 其实最后都是一个套路给View一个Controller，想当于View层换了一个Controller public void setImageURI(Uri uri, @Nullable Object callerContext) { DraweeController controller = mSimpleDraweeControllerBuilder .setCallerContext(callerContext) .setUri(uri) .setOldController(getController()) .build(); setController(controller); } 参考 源码解析 FrescoDemo Fresco.cn","categories":[],"tags":[]}]}